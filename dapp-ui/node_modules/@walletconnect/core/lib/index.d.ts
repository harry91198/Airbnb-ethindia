import { IConnector, ICryptoLib, ITransportLib, ISessionStorage, ISessionStatus, ISessionError, IJsonRpcResponseSuccess, IJsonRpcResponseError, IJsonRpcRequest, ITxData, IClientMeta, IWalletConnectOptions, IUpdateChainParams } from '@walletconnect/types';
declare class Connector implements IConnector {
    private cryptoLib;
    private protocol;
    private version;
    private _bridge;
    private _key;
    private _nextKey;
    private _clientId;
    private _clientMeta;
    private _peerId;
    private _peerMeta;
    private _handshakeId;
    private _handshakeTopic;
    private _accounts;
    private _chainId;
    private _networkId;
    private _rpcUrl;
    private _transport;
    private _eventManager;
    private _connected;
    private _storage;
    constructor(cryptoLib: ICryptoLib, opts: IWalletConnectOptions, transport?: ITransportLib | null, storage?: ISessionStorage | null, clientMeta?: IClientMeta | null);
    bridge: string;
    key: string;
    nextKey: string;
    clientId: string;
    peerId: any;
    clientMeta: any;
    peerMeta: any;
    handshakeTopic: any;
    handshakeId: any;
    uri: string;
    chainId: any;
    networkId: any;
    accounts: any;
    rpcUrl: any;
    connected: any;
    pending: any;
    session: {
        connected: boolean;
        accounts: string[];
        chainId: number;
        bridge: string;
        key: string;
        clientId: string;
        clientMeta: IClientMeta | null;
        peerId: string;
        peerMeta: IClientMeta | null;
        handshakeId: number;
        handshakeTopic: string;
    };
    on(event: string, callback: (error: Error | null, payload: any | null) => void): void;
    createSession(opts?: {
        chainId: number;
    }): Promise<void>;
    approveSession(sessionStatus: ISessionStatus): void;
    rejectSession(sessionError?: ISessionError): void;
    updateSession(sessionStatus: ISessionStatus): void;
    killSession(sessionError?: ISessionError): Promise<void>;
    sendTransaction(tx: ITxData): Promise<any>;
    signTransaction(tx: ITxData): Promise<any>;
    signMessage(params: any[]): Promise<any>;
    signPersonalMessage(params: any[]): Promise<any>;
    signTypedData(params: any[]): Promise<any>;
    updateChain(chainParams: IUpdateChainParams): Promise<any>;
    unsafeSend(request: IJsonRpcRequest): Promise<IJsonRpcResponseSuccess | IJsonRpcResponseError>;
    sendCustomRequest(request: Partial<IJsonRpcRequest>): Promise<any>;
    approveRequest(response: Partial<IJsonRpcResponseSuccess>): void;
    rejectRequest(response: Partial<IJsonRpcResponseError>): void;
    protected _sendRequest(request: Partial<IJsonRpcRequest>, _topic?: string): Promise<void>;
    protected _sendResponse(response: IJsonRpcResponseSuccess | IJsonRpcResponseError): Promise<void>;
    protected _sendSessionRequest(request: IJsonRpcRequest, errorMsg: string, _topic?: string): Promise<void>;
    protected _sendCallRequest(request: IJsonRpcRequest): Promise<any>;
    protected _formatRequest(request: Partial<IJsonRpcRequest>): IJsonRpcRequest;
    protected _formatResponse(response: Partial<IJsonRpcResponseSuccess | IJsonRpcResponseError>): IJsonRpcResponseSuccess | IJsonRpcResponseError;
    private _handleSessionDisconnect;
    private _handleSessionResponse;
    private _handleIncomingMessages;
    private _subscribeToSessionRequest;
    private _subscribeToResponse;
    private _subscribeToSessionResponse;
    private _subscribeToCallResponse;
    private _subscribeToInternalEvents;
    private _formatUri;
    private _parseUri;
    private _generateKey;
    private _encrypt;
    private _decrypt;
    private _getStorageSession;
    private _setStorageSession;
    private _removeStorageSession;
    private _manageStorageSession;
}
export default Connector;
//# sourceMappingURL=index.d.ts.map